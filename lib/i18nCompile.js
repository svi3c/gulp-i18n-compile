// Generated by CoffeeScript 1.10.0
var PLUGIN_NAME, convert, gutil, merge, path, through;

through = require("through2");

convert = require("./convert");

gutil = require("gulp-util");

path = require("path");

PLUGIN_NAME = require("../package.json").name;

merge = require("merge");

module.exports = function(fileName, arg) {
  var allTranslations, collector, latestFile, localePlaceholder, nothingToWrite, writer;
  localePlaceholder = (arg != null ? arg : {}).localePlaceholder;
  allTranslations = {};
  nothingToWrite = false;
  latestFile = null;
  if (!fileName) {
    throw new gutil.PluginError(PLUGIN_NAME, "fileName of output is missing.");
  }
  collector = function(file, encoding, callback) {
    var e, error, fileTranslations, translations;
    if (file.isNull()) {
      this.push(file);
      nothingToWrite = true;
    } else if (file.isStream()) {
      this.emit('error', new gutil.PluginError(PLUGIN_NAME, 'Streaming not supported.'));
    } else {
      try {
        translations = JSON.parse(file.contents.toString());
      } catch (error) {
        e = error;
        this.emit('error', new gutil.PluginError(PLUGIN_NAME, "The file " + file.path + " seems not to contain valid JSON."));
      }
      fileTranslations = convert(translations);
      allTranslations = merge.recursive(true, allTranslations, fileTranslations);
      latestFile = file;
    }
    return callback();
  };
  writer = function(callback) {
    var createOutFile, locale, translations;
    createOutFile = function(fileName, jsonContent) {
      var file;
      file = latestFile.clone({
        contents: false
      });
      file.path = path.join(latestFile.base, fileName);
      file.contents = new Buffer(JSON.stringify(jsonContent));
      return file;
    };
    if (localePlaceholder != null) {
      for (locale in allTranslations) {
        translations = allTranslations[locale];
        this.push(createOutFile(fileName.replace(localePlaceholder, locale), translations));
      }
    } else {
      this.push(createOutFile(fileName, allTranslations));
    }
    return callback();
  };
  return through.obj(collector, writer);
};
